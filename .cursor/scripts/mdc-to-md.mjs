import fs from 'node:fs';
import path from 'node:path';

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function isFrontmatterStart(text) {
  return text.startsWith('---\n') || text.startsWith('---\r\n');
}

export function convertMdcToMd(text) {
  if (!isFrontmatterStart(text)) return text;

  const match = text.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/);
  if (!match) return text;

  const yaml = match[1]?.trimEnd() ?? '';
  const rest = text.slice(match[0].length).trimStart();

  return `<!-- Cursor frontmatter\n${yaml}\n-->\n\n${rest}`;
}

function walkFiles(rootDir) {
  /** @type {string[]} */
  const out = [];

  /** @param {string} dir */
  function recurse(dir) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const e of entries) {
      const full = path.join(dir, e.name);
      if (e.isDirectory()) {
        // Skip common junk dirs
        if (e.name === 'node_modules' || e.name === '.git') continue;
        recurse(full);
      } else if (e.isFile()) {
        out.push(full);
      }
    }
  }

  recurse(rootDir);
  return out;
}

export function exportRulesToMarkdown({ hubRoot }) {
  const srcRules = path.join(hubRoot, 'rules');
  const outRules = path.join(hubRoot, 'dist', 'exports', 'rules-md');

  if (!fs.existsSync(srcRules)) {
    throw new Error(`Missing rules directory: ${srcRules}`);
  }

  ensureDir(outRules);

  const files = walkFiles(srcRules);
  let converted = 0;
  let copied = 0;

  for (const file of files) {
    const rel = path.relative(srcRules, file);
    const ext = path.extname(file).toLowerCase();

    if (ext === '.mdc') {
      const destRel = rel.replace(/\.mdc$/i, '.md');
      const dest = path.join(outRules, destRel);
      ensureDir(path.dirname(dest));

      const content = fs.readFileSync(file, 'utf8');
      fs.writeFileSync(dest, convertMdcToMd(content), 'utf8');
      converted++;
      continue;
    }

    if (ext === '.md') {
      const dest = path.join(outRules, rel);
      ensureDir(path.dirname(dest));
      fs.copyFileSync(file, dest);
      copied++;
      continue;
    }
  }

  return { outRules, converted, copied };
}

export function exportVscodeCopilotInstructions({ hubRoot }) {
  const outDir = path.join(hubRoot, 'dist', 'exports', 'vscode');
  ensureDir(outDir);

  const dest = path.join(outDir, 'copilot-instructions.md');

  // Keep it concise: VS Code will ingest this file on every chat request.
  const content = `<!-- Generated by cursor-hub. Do not edit manually. -->\n\n# Copilot Instructions\n\nThis workspace uses a shared “AI rules hub” stored in a central \`.cursor/\` source-of-truth.\n\n## Core rules\n\n- Follow repository rules in \`.cursor/rules/RULE.md\` when present.\n- Prefer \`pnpm\` over npm/yarn.\n- No secrets in code; validate external input; avoid unsafe shell execution.\n- Keep files <300 lines and functions <50 lines.\n\n## Where to look\n\n- **Rules**: \`.cursor/rules/\` (exported from Cursor \`.mdc\` where needed)\n- **Skills**: \`.cursor/skills/\`\n- **Hooks**: \`.cursor/hooks/\`\n- **Agents**: \`.cursor/agents/\`\n\nIf you are unsure which rule applies, ask clarifying questions.\n`;

  fs.writeFileSync(dest, content, 'utf8');
  return { dest };
}

