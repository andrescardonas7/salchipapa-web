---
description: Structured logging standards for application code
globs: ['**/*.ts', '**/*.tsx', '**/*.js', '**/*.jsx']
alwaysApply: false
---

# Logging Standards

## Core Rule

**Rule**: Use structured logging with correlation IDs; never log sensitive data.

## Logger Setup

**Rule**: Use `pino` (fastest) or `winston` for structured logging.

### Pino Setup

**Example**:

```typescript
// lib/logger.ts
import pino from 'pino';

export const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: process.env.NODE_ENV === 'development'
    ? {
        target: 'pino-pretty',
        options: { colorize: true },
      }
    : undefined,
  formatters: {
    level: (label) => {
      return { level: label };
    },
  },
  timestamp: pino.stdTimeFunctions.isoTime,
});
```

### Winston Setup

**Example**:

```typescript
// lib/logger.ts
import winston from 'winston';

export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console({
      format: process.env.NODE_ENV === 'development'
        ? winston.format.combine(
            winston.format.colorize(),
            winston.format.simple()
          )
        : winston.format.json(),
    }),
  ],
});
```

## Log Levels

**Rule**: Use appropriate log levels based on severity.

**Hierarchy**: `fatal` > `error` > `warn` > `info` > `debug` > `trace`

**Default Production**: `info`

**Usage Guidelines**:
- `fatal`: Application cannot continue (crash imminent)
- `error`: Error occurred but application continues
- `warn`: Warning condition (deprecated API, fallback used)
- `info`: Informational messages (user actions, system events)
- `debug`: Detailed information for debugging
- `trace`: Very detailed tracing information

**Example**:

```typescript
logger.fatal({ msg: 'Database connection lost, shutting down' });
logger.error({ msg: 'Failed to process payment', orderId });
logger.warn({ msg: 'Using deprecated API endpoint', endpoint });
logger.info({ msg: 'User logged in', userId });
logger.debug({ msg: 'Processing request', requestId });
logger.trace({ msg: 'Function entry', functionName });
```

## Required Fields

**Rule**: Always include context in log entries.

**Required Fields**:
- `msg`: Human-readable message
- `timestamp`: ISO 8601 timestamp (usually automatic)
- `level`: Log level
- `requestId`: Correlation ID (if available)
- `userId`: User ID (if applicable)

**Example**:

```typescript
logger.info({
  msg: 'User logged in',
  userId: user.id,
  requestId: req.id,
  timestamp: new Date().toISOString(),
  ip: req.ip,
  userAgent: req.headers['user-agent'],
});
```

## Error Logging Pattern

**Rule**: Log errors with full context and stack traces.

**Example**:

```typescript
// ✅ Good: Structured with context
try {
  await processPayment(order);
} catch (error) {
  logger.error({
    msg: 'Payment processing failed',
    error: error instanceof Error ? error.message : String(error),
    stack: error instanceof Error ? error.stack : undefined,
    orderId: order.id,
    userId: order.userId,
    amount: order.total,
    paymentMethod: order.paymentMethod,
    requestId: req.id,
  });
  throw new PaymentError('Failed to process payment');
}

// ❌ Bad: console.log without context
catch (error) {
  console.log(`Error: ${error}`);
}
```

## Security: Never Log Sensitive Data

**Rule**: Never log passwords, tokens, API keys, or PII.

**Sensitive Data**:
- Passwords and password hashes
- API keys and tokens
- Credit card numbers
- Social security numbers
- Full email addresses (mask if needed)

**Example**:

```typescript
// ❌ Bad: Exposes secrets
logger.info({
  password: user.password,
  token: apiKey,
  creditCard: cardNumber,
});

// ✅ Good: Sanitized
logger.info({
  userId: user.id,
  email: maskEmail(user.email), // e.g., "us***@example.com"
  hasToken: !!apiKey, // Boolean, not the actual token
});

// Helper function
function maskEmail(email: string): string {
  const [local, domain] = email.split('@');
  const masked = local.slice(0, 2) + '***' + local.slice(-1);
  return `${masked}@${domain}`;
}
```

## Correlation IDs

**Rule**: Use correlation IDs to trace requests across services.

### Express.js Middleware

**Example**:

```typescript
// middleware/requestId.ts
import { v4 as uuidv4 } from 'uuid';
import { Request, Response, NextFunction } from 'express';
import { logger } from '@/lib/logger';

export const requestIdMiddleware = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  // Use existing request ID from header or generate new one
  const requestId = req.headers['x-request-id'] as string || uuidv4();

  // Set response header
  res.setHeader('X-Request-Id', requestId);

  // Create child logger with request ID
  req.log = logger.child({ requestId });

  // Attach to request object
  req.id = requestId;

  next();
};

// Usage in routes
app.get('/api/users', (req, res) => {
  req.log.info({ msg: 'Fetching users', userId: req.user?.id });
  // All logs from this request will include requestId
});
```

### Next.js Middleware

**Example**:

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { v4 as uuidv4 } from 'uuid';

export function middleware(request: NextRequest) {
  const requestId = request.headers.get('x-request-id') || uuidv4();

  const response = NextResponse.next();
  response.headers.set('X-Request-Id', requestId);

  return response;
}
```

## Local Development

**Rule**: Use pretty-printed logs in development, JSON in production.

**Commands**:

```bash
# Pretty-printed logs (development)
LOG_LEVEL=debug pnpm dev

# JSON logs (production-like)
LOG_LEVEL=info pnpm dev
```

**Environment Variables**:

```bash
# .env.development
LOG_LEVEL=debug

# .env.production
LOG_LEVEL=info
```

## Testing

**Rule**: Mock logger in tests to avoid console noise.

**Example**:

```typescript
// test/setup.ts
import { jest } from '@jest/globals';

global.logger = {
  info: jest.fn(),
  error: jest.fn(),
  warn: jest.fn(),
  debug: jest.fn(),
  fatal: jest.fn(),
  trace: jest.fn(),
  child: jest.fn(() => global.logger),
};

// Usage in tests
describe('UserService', () => {
  it('should log user creation', async () => {
    await userService.createUser(userData);
    expect(global.logger.info).toHaveBeenCalledWith(
      expect.objectContaining({
        msg: 'User created',
        userId: expect.any(String),
      })
    );
  });
});
```

## Log Aggregation

**Rule**: Send logs to centralized logging service in production.

**Tools**:
- **Datadog**: `pino-datadog` transport
- **Sentry**: Error tracking and logging
- **CloudWatch**: AWS logging service
- **Elasticsearch**: Self-hosted log aggregation

**Example** (Pino with Datadog):

```typescript
import pino from 'pino';

export const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: process.env.NODE_ENV === 'production'
    ? {
        target: 'pino-datadog',
        options: {
          apiKey: process.env.DATADOG_API_KEY,
          service: 'my-app',
        },
      }
    : {
        target: 'pino-pretty',
        options: { colorize: true },
      },
});
```

## Best Practices

### Structured Data

**Rule**: Use objects, not string interpolation.

**Example**:

```typescript
// ✅ Good: Structured
logger.info({
  msg: 'User updated profile',
  userId: user.id,
  changes: { email: true, name: false },
});

// ❌ Bad: String interpolation
logger.info(`User ${user.id} updated profile`);
```

### Context Propagation

**Rule**: Use child loggers to propagate context.

**Example**:

```typescript
// Create child logger with user context
const userLogger = logger.child({ userId: user.id, role: user.role });

// All logs from userLogger will include userId and role
userLogger.info({ msg: 'Processing order' });
// Output: { level: 'info', msg: 'Processing order', userId: '123', role: 'admin' }
```

### Performance

**Rule**: Use appropriate log levels to avoid performance impact.

**Guidelines**:
- Use `debug`/`trace` sparingly in production
- Avoid logging in hot paths (loops, frequent functions)
- Use conditional logging for expensive operations

**Example**:

```typescript
// ✅ Good: Conditional logging
if (logger.level === 'debug') {
  logger.debug({ expensiveData: computeExpensiveData() });
}

// ❌ Bad: Always computes expensive data
logger.debug({ expensiveData: computeExpensiveData() });
```

**Reference**: See `code-quality/03_error-handling.mdc` for error handling patterns.
